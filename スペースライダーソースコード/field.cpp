/*******************************************************************************
* タイトル:		フィールドプログラム
* プログラム名:		field.cpp
* 作成者:		CP11SATA  15  Kim Nakamura
* 作成日:		2016/02/20
********************************************************************************
* 更新履歴:		- 2016/02/20　Kim Nakamura
*			- V1.00　Initial Version
*			レース用フィールドフレームの関数の追加
*			・レース用フィールドの作成
*	3/4		・レース用フィールドフレーム数は10枚必要
*			・2枚はスタートとゴールである！
*******************************************************************************/
/*******************************************************************************
* scanf のwarning防止 
*******************************************************************************/
#define _CRT_SECURE_NO_WARNINGS

/*******************************************************************************
* インクルードファイル
*  必要な情報
*  	表示のための基本要素
*  	フィールドの自身情報
*  	プレイヤーの情報
*******************************************************************************/
#include "main.h"
#include "field.h"
#include "player.h"
#include "computer.h"

/*******************************************************************************
* マクロ定義
*******************************************************************************/


/*******************************************************************************
* 構造体定義
*******************************************************************************/


/*******************************************************************************
* プロトタイプ宣言
*******************************************************************************/


/*******************************************************************************
* グローバル変数
*******************************************************************************/
// ヘッダーファイルからプレイヤー構造体のグローバル宣言
FIELD g_nField;

/*******************************************************************************
* 関数名:	void InitField( void ):（初期化）関数
* 引数:		void
* 戻り値:	なし
* 説明:		フィールドの初期設定
*******************************************************************************/
void InitField( void )
{
	// プログラムスタート

	// 初期化
	g_nField.nCnt     = ZERO_INT;
	g_nField.nCntSec  = ZERO_INT;
	g_nField.nRanking = ZERO_INT;
	g_nField.bPlay   = false;
	g_nField.bTitle  = false;
	g_nField.bStart  = false;

	RaceFieldStart();			// スタートフィールドの表示

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void UpdateField( void ):（更新）関数
* 引数:		void
* 戻り値:	なし
* 説明:		フィールドの更新処理
*******************************************************************************/
void UpdateField( void )
{
	// プログラムスタート

	// タイトルの表示
	if(g_nField.bTitle == false)
	{
		title();
		g_nField.bTitle = true;		// タイトル表示しましたよ
	}//if.fin

	// エンターキーを押したらゲームスタート
	if(INP(PK_ENTER) && g_nField.bPlay == false)
	{
		// ゲームスタート
		g_nField.bStart = true;
	}//if.fin

	// 初期化、各フィールドデータを配列に統合
	if(g_nField.bStart == true)
	{
		RaceFieldStart();			// スタートフィールドの表示
		g_nField.bStart = false;
		g_nField.bPlay  = true;
	}//if.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void DrawField( void ):（描画）関数
* 引数:		void
* 戻り値:	なし
* 説明:		レースフィールドの描画処理
*	3/4		レースフィールドを２次元配列で18の描画データの受け取り
*			ゴールは既に作っておくこと！（2次元配列で）
*******************************************************************************/
void DrawField( void )
{
	// プログラムスタート

	// プレイヤーの構造体ポインタ変数宣言
	PLAYER *pPlayer;

	// プレイヤー情報のコピーの取得
	pPlayer = GetPlayer();

	// ゲーム開始
	if(g_nField.bPlay == true)
	{
		// プレイヤーのＸ座標軸が79毎、次のコースの描画する
		if((g_nField.nCnt == 1  ) && (g_nField.nCntSec == 0))
		{
			RaceField_40_79_and_320_359_and_640_679();			// ０１and０８and１６：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 2) && (g_nField.nCntSec == 1))
		{
			RaceField_80_119_and_360_399_and_440_479();			// ０２and０９and１１：加速地１
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 3) && (g_nField.nCntSec == 2))
		{
			RaceField_120_159_and_480_519();					// ０３and１２：休憩地１
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 4) && (g_nField.nCntSec == 3))
		{
			RaceField_160_199_and_520_559_and_680_719 ();		// ０４and１３and１７：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 5) && (g_nField.nCntSec == 4))
		{
			RaceField_200_239_and_400_439();					// ０５and１０：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 6) && (g_nField.nCntSec == 5))
		{
			RaceField_240_279_and_560_599();					// ０６and１４：加速地２
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 7) && (g_nField.nCntSec == 6))
		{
			RaceField_280_319_and_600_639();					// ０７and１５：休憩地２
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 8) && (g_nField.nCntSec == 7))
		{
			RaceField_40_79_and_320_359_and_640_679();			// ０１and０８and１６：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 9) && (g_nField.nCntSec == 8))
		{
			RaceField_80_119_and_360_399_and_440_479();			// ０２and０９and１１：加速地１
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 10) && (g_nField.nCntSec == 9))
		{
			RaceField_200_239_and_400_439();					// ０５and１０：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 11) && (g_nField.nCntSec == 10))
		{
			RaceField_80_119_and_360_399_and_440_479();			// ０２and０９and１１：加速地１
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 12) && (g_nField.nCntSec == 11))
		{
			RaceField_120_159_and_480_519();					// ０３and１２：休憩地１
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 13) && (g_nField.nCntSec == 12))
		{
			RaceField_160_199_and_520_559_and_680_719 ();		// ０４and１３and１７：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 14) && (g_nField.nCntSec == 13))
		{
			RaceField_240_279_and_560_599();					// ０６and１４：加速地２
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 15) && (g_nField.nCntSec == 14))
		{
			RaceField_280_319_and_600_639();					// ０７and１５：休憩地２
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 16) && (g_nField.nCntSec == 15))
		{
			RaceField_40_79_and_320_359_and_640_679();			// ０１and０８and１６：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 17) && (g_nField.nCntSec == 16))
		{
			RaceField_160_199_and_520_559_and_680_719 ();		// ０４and１３and１７：ふつう
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 18) && (g_nField.nCntSec == 17))
		{
			RaceField_720_739();								// １８：スパートポイント地
			g_nField.nCntSec++;									// インクリメント
		}
		else if((g_nField.nCnt == 19) && (g_nField.nCntSec == 18))
		{
			RaceFieldGoal();									// １９：ゴール
			g_nField.nCntSec++;									// インクリメント
		}//if.fin

	}//if.fin
	
	// プログラムエンド
 }

/*******************************************************************************
* 関数名:	void UninitField( void ):（終了）関数
* 引数:		void
* 戻り値:	なし
* 説明:		フィールドの終了処理
*******************************************************************************/
void UninitField( void )
{
	// プログラムスタート

	

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceFieldStart( void )
* 引数:		void
* 戻り値:	なし
* 説明:		スタート
*******************************************************************************/
void RaceFieldStart( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）（スタートと書いてある）
		{0,10,10,10,10,10,0,0,0,0,10,10,10,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0},
		{0,0,0,0,0,10,0,0,0,0,10,0,0,0,10,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0},
		{0,0,0,0,10,0,0,0,0,10,0,10,0,0,10,0,0,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0,10,10,10,0,0,0},
		{0,0,0,10,0,10,0,0,0,0,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,10,0,0},
		{0,10,10,0,0,0,10,0,0,0,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,6,3,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,6,2,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,2,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,2,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceFieldGoal( void )
* 引数:		void
* 戻り値:	なし
* 説明:		ゴール
*******************************************************************************/
void RaceFieldGoal( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,1,0,0,0,10,10,10,10,10,10,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,0,0,0,0,1,0},
		{0,1,0,0,0,0,0,0,0,0,10,10,0,10,0,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,0,0,0,0,1,0},
		{0,1,0,0,0,0,0,0,0,0,10,0,10,0,0,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0,10,0,10,0,0,10,0,0,1,0},
		{0,1,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,10,0,10,0,0,0,1,0},
		{0,1,0,0,0,10,10,10,10,10,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,10,10,0,0,0,0,1,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,10,10,11,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,11,10,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,6,1,1,1,5,1,1,1,1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列７６０番地）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_40_79_and_320_359_and_640_679 ( void )
* 引数:		void
* 戻り値:	なし											　■
* 説明:		ふつう地コース０１と０８と１６で使用			■■
*			レースコース４０  〜７９						　■
*			レースコース３２０〜３５９						　■
*			レースコース６４０〜６７９						■■■
*******************************************************************************/
void RaceField_40_79_and_320_359_and_640_679 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,2,3,3,3,3,3,4,3,0,3,3,3,3,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,3,3,3,3,3,3,4,3,0,3,3,3,2,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,2,3,3,3,3,3,3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,3,3,3,3,3,3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列４０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_80_119_and_360_399_and_440_479 ( void )
* 引数:		void
* 戻り値:	なし											■■■
* 説明:		加速地１コース０２と０９と１１で使用			■　■
*			レースコース８０  〜１１９						　　■
*			レースコース３６０〜３９９						　■
*			レースコース４４０〜４７９						■■■
*******************************************************************************/
void RaceField_80_119_and_360_399_and_440_479 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,9,9,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,2,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,8,8,0,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0},
		{0,0,0,0,0,0,0,0,7,7,0,0,0,5,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0},
		{0,0,0,0,0,0,0,2,2,0,0,0,0,0,6,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0},
		{0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0},
		{0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,5,6,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列８０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_120_159_and_480_519 ( void )
* 引数:		void
* 戻り値:	なし											■■■
* 説明:		休憩地１コース０３と１２で使用					　　■
*			レースコース１２０〜１５９						■■■
*			レースコース４８０〜５１９						　　■
*															■■■
*******************************************************************************/
void RaceField_120_159_and_480_519 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,3,5,5,3,6,3},
		{3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,3,5,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列１２０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_160_199_and_520_559_and_680_719 ( void )
* 引数:		void
* 戻り値:	なし											■　■
* 説明:		ふつうコース０４と１３と１７で使用				■　■
*			レースコース１６０〜１９９						■■■
*			レースコース５２０〜５５９						　　■
*			レースコース６８０〜７１９						　　■
*******************************************************************************/
void RaceField_160_199_and_520_559_and_680_719 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,6,3,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,5,3,3,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,5,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,3,4,4},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,3,3,4,4,2},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0},
		{0,0,0,0,0,3,3,3,3,3,3,5,3,3,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列１６０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_200_239_and_400_439 ( void )
* 引数:		void
* 戻り値:	なし											■■■
* 説明:		休憩地２コース０５と１０で使用					■
*			レースコース２００〜２３９						■■■
*			レースコース４００〜５３９						　　■
*															■■■
*******************************************************************************/
void RaceField_200_239_and_400_439 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,2,3,3,3,3,3,3,3,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,4,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,5,3,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,5,2,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,6,3,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,6,2,0},
		{0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列２００番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_240_279_and_560_599 ( void )
* 引数:		void
* 戻り値:	なし											■■■
* 説明:		加速地２コース０６と１４で使用					■
*			レースコース２４０〜２７９						■■■
*			レースコース５６０〜５９９						■　■
*															■■■
*******************************************************************************/
void RaceField_240_279_and_560_599 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,3,3,3,3,3,3,3,4,4,3,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,3,3,3,3,3,3,3,3,4,4,3,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,3,3,3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,2,4,4,3,5,3,6,3},
		{0,0,0,0,0,2,3,3,3,3,3,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,3,4,4,3,5,3,6,2},
		{0,0,0,0,0,3,3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列２４０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_280_319_and_600_639 ( void )
* 引数:		void
* 戻り値:	なし											■■■
* 説明:		休憩地２コース０７と１５で使用					■　■
*			レースコース２８０〜３１９						　　■
*			レースコース６００〜６３９						　　■
*															　　■
*******************************************************************************/
void RaceField_280_319_and_600_639 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{10,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,10},
		{10,0,0,1,1,1,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,0,0,10},
		{10,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,10},
		{10,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,10},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,3,5,5,3,6,3},
		{3,3,3,3,3,3,3,4,4,4,3,3,3,3,3,3,3,3,3,5,5,5,3,3,3,3,3,3,3,3,3,3,4,4,3,5,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列２８０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void RaceField_720_739 ( void )
* 引数:		void											■■■
* 戻り値:	なし											■　■
* 説明:		スパートポイント地コース１８で使用				■■■
*			レースコース７２０〜７３９						■　■
*															■■■
*******************************************************************************/
void RaceField_720_739 ( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// ポイントプラスの星（背景）
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// メインコース
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,3,3,4,4,3,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,4,4,3,5,3,6,2},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,0,0,0,2,3,3,3,3,3,3,3,3,4,4,3,5,3,6,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,3,4,4,3,5,3,6,2},
		{0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},

		// 何の変哲もないただの地面
		{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(YELLOW);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("☆");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納（０＋配列７２０番地目から）
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];

		}//forX.fin

	}//forY.fin

	// プログラムエンド
}

/*******************************************************************************
* 関数名:	FIELD *GetField( void ):（地面情報の公開）関数
* 引数:		void
* 戻り値:	return &g_aField[ZERO_INT];
* 説明:		フィールド情報の公開
*******************************************************************************/
FIELD *GetField( void )
{
	// プログラムスタート

	// フィールド情報の値を返す
	return &g_nField;
	
	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void title( void )
* 引数:		void
* 戻り値:	なし
* 説明:		タイトル
*******************************************************************************/
void title( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		// 現在位置の表示バー
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,3,3,3,3,3,3,6,0,0,0,3,0,0,5,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,3,3,6,0},
		{0,0,0,0,0,0,3,6,0,0,3,6,3,0,3,0,3,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,0},
		{0,0,0,0,0,3,6,0,0,3,6,0,0,3,6,3,5,0,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,0,0},
		{0,0,0,0,3,6,0,0,3,6,0,0,0,0,3,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,3,6,0,0,0},
		{0,0,0,3,6,3,6,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,3,6,0,0},
		{0,0,3,6,0,0,3,6,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,0,0,3,6,0},
		{0,3,6,0,0,0,0,3,6,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,0,0,0,0,3,6},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,0,3,6,3,6,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,3,3,3,3,6,0,0,0,0,0,0,3,6,0,3,3,3,3,3,6,0,3,6,3,6,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,6,0,0,3,6,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,3,3,3,3,3,3,6,0,3,3,6,3,6,0,3,6,3,0,0,3,6,0,5,6,6,6,6,6,6,6,6,5,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,3,6,0,0,0,0,3,6,3,0,0,0,3,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,3,6,0,0,0,0,3,6,0,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,3,6,0,0,0,0,0,3,6,0,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,3,3,3,6,0,0,0,0,0,0,3,6,0,0,0,3,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,9,3,3,3,3,3,3,3,3,3,3,3,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,3,3,3,3,3,3,3,3,3,3,3,3,3},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,7,5,6,5,6,5,6,5,6,5,6,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,6,12,0,0,0,0,0,0,0,5,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,5,6,5,6,5,6,5,6,5,6,0,0,0,0},

		// 何の変哲もないただの地面
		{1,4,1,5,1,6,1,1,1,1,1,1,1,4,1,5,1,6,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
	};

	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)				// １：地面
			{
				COLOR(LIME);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == SLOPE)		// ２：坂
			{
				COLOR(H_CYAN);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == COURSE)		// ３：床
			{
				COLOR(WHITE);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == GOOD)			// ４：GOOD床
			{
				COLOR(RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == VERYGOOD)		// ５：VERYGOOD床
			{
				COLOR(H_RED);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == EXCELLENT)	// ６：EXCELLENT床
			{
				COLOR(YELLOW);
				printf("□");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_GOOD)		// ７：GOOD坂
			{
				COLOR(RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_VERYGOOD)	// ８：VERYGOOD坂
			{
				COLOR(H_RED);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == S_EXCELLENT)	// ９：EXCELLENT坂
			{
				COLOR(YELLOW);
				printf("／");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR)			// １０：星(飾り)
			{
				COLOR(LIME);
				printf("エンターを押すまで練習ができるよ！");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +1)		// １１：星(飾り)
			{
				COLOR(LIME);
				printf("スペースキーで赤のキミがジャンプするよ！");
			}
			else if(nRaceField[nVertical][nHorizontal] == STAR +2)		// １２：星(飾り)
			{
				COLOR(LIME);
				printf("プリーズエンター");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)		// ０：空白
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin

	// 配列の先頭アドレスを引数としてUpdatePlayerに渡す
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// 2次元配列の先頭から構造体内の専用変数に格納
			g_nField.nPosition[nVertical][nHorizontal] = nRaceField[nVertical][nHorizontal];
		}//forX.fin

	}//forY.fin
	
	// プログラムエンド
}

/*******************************************************************************
* 関数名:	void result( void )
* 引数:		void
* 戻り値:	なし
* 説明:		結果発表〜
*******************************************************************************/
void result( void )
{
	// プログラムスタート

	// 2次元配列で使用する変数の宣言
	int nVertical;
	int nHorizontal;
	int nLocateX = ONE_INT;
	int nLocateY = ONE_INT;

	// 2次元配列の初期化処理（要素数が25×40のint型2次元配列を宣言）
	int nRaceField[MAX_VERTICAL][MAX_HORAIZONTAL] = 
	{
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0},
		{0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0},
		{0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0},
		{0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},
		{0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	};
	
	// レース用フィールドの表示処理
	for(nVertical = ZERO_INT; nVertical < MAX_VERTICAL; nVertical++)				// 縦軸のループ
	{
		LOCATE(nLocateX, nLocateY++);

		for(nHorizontal = ZERO_INT; nHorizontal < MAX_HORAIZONTAL; nHorizontal++)	// 横軸のループ
		{
			// フィールドの要素の表示
			if(nRaceField[nVertical][nHorizontal] == BLOCK)
			{
				COLOR(CYAN);
				printf("■");
			}
			else if(nRaceField[nVertical][nHorizontal] == 2)
			{
				BACKCOLOR(WHITE);
				printf("Ｒボタンちょい長押しでタイトルに戻る");
			}
			else if(nRaceField[nVertical][nHorizontal] == SPACE)
			{
				BACKCOLOR(BLACK);
				printf("　");
			}//if.fin
	
		}//forX.fin

		printf("\0");		// NULL

	}//forY.fin


	// プログラムエンド
}

